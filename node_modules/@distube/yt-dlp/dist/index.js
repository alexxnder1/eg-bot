"use strict";
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  YtDlpPlugin: () => YtDlpPlugin,
  download: () => download,
  json: () => json,
  raw: () => raw
});
module.exports = __toCommonJS(src_exports);

// src/wrapper.ts
var import_dargs = __toESM(require("dargs"));
var import_execa = __toESM(require("execa"));
var import_mkdirp = __toESM(require("mkdirp"));
var import_promises = __toESM(require("fs/promises"));
var import_undici = require("undici");

// src/env.ts
var import_path = __toESM(require("path"));
var e = /* @__PURE__ */ __name((key) => process.env[key], "e");
var YTDLP_DISABLE_DOWNLOAD = !!e("YTDLP_DISABLE_DOWNLOAD");
var YTDLP_URL = e("YTDLP_URL") || "https://api.github.com/repos/yt-dlp/yt-dlp/releases?per_page=1";
var YTDLP_IS_WINDOWS = e("YTDLP_IS_WINDOWS") || process.platform === "win32";
var YTDLP_DIR = e("YTDLP_DIR") || import_path.default.join(__dirname, "..", "bin");
var YTDLP_FILENAME = e("YTDLP_FILENAME") || `yt-dlp${YTDLP_IS_WINDOWS ? ".exe" : ""}`;
var YTDLP_PATH = import_path.default.join(YTDLP_DIR, YTDLP_FILENAME);

// src/wrapper.ts
var makeRequest = /* @__PURE__ */ __name(async (url) => {
  const response = await (0, import_undici.request)(url, { headers: { "user-agent": "distube" } });
  if (!response.statusCode)
    throw new Error(`Cannot make requests to '${url}'`);
  if (response.statusCode.toString().startsWith("3")) {
    if (!response.headers.location)
      throw new Error(`Cannot redirect to '${url}'`);
    for await (const _chunk of response.body) {
    }
    return makeRequest(response.headers.location);
  }
  if (response.statusCode.toString().startsWith("2"))
    return response;
  throw new Error(`${url}
Status code ${response.statusCode.toString()}`);
}, "makeRequest");
var args = /* @__PURE__ */ __name((url, flags = {}) => [url].concat((0, import_dargs.default)(flags, { useEquals: false })).filter(Boolean), "args");
var raw = /* @__PURE__ */ __name((url, flags, options) => (0, import_execa.default)(YTDLP_PATH, args(url, flags), options), "raw");
var json = /* @__PURE__ */ __name((url, flags, options) => raw(url, flags, options).then(({ stdout }) => JSON.parse(stdout)), "json");
var binContentTypes = ["binary/octet-stream", "application/octet-stream", "application/x-binary"];
var getBinary = /* @__PURE__ */ __name(async (url) => {
  const response = await makeRequest(url);
  const contentType = response.headers["content-type"];
  if (binContentTypes.includes(contentType ?? ""))
    return { buffer: await response.body.arrayBuffer(), version: "N/A" };
  const [{ assets, tag_name }] = await response.body.json();
  const { browser_download_url } = assets.find(({ name }) => name === YTDLP_FILENAME);
  return await makeRequest(browser_download_url).then(async (r) => ({
    buffer: await r.body.arrayBuffer(),
    version: typeof tag_name === "string" ? tag_name : "N/A"
  }));
}, "getBinary");
var download = /* @__PURE__ */ __name(() => Promise.all([getBinary(YTDLP_URL), (0, import_mkdirp.default)(YTDLP_DIR)]).then(([{ buffer, version }]) => {
  import_promises.default.writeFile(YTDLP_PATH, Buffer.from(buffer), { mode: 493 });
  return version;
}), "download");

// src/index.ts
var import_distube = require("distube");
var isPlaylist = /* @__PURE__ */ __name((i) => Array.isArray(i.entries), "isPlaylist");
var YtDlpPlugin = class extends import_distube.ExtractorPlugin {
  constructor({ update } = {}) {
    super();
    if (update ?? true)
      download().catch(() => void 0);
  }
  validate() {
    return true;
  }
  async resolve(url, { member, metadata }) {
    const info = await json(url, {
      dumpSingleJson: true,
      noWarnings: true,
      noCallHome: true,
      preferFreeFormats: true,
      skipDownload: true,
      simulate: true
    }).catch((e2) => {
      throw new import_distube.DisTubeError("YTDLP_ERROR", `${e2.stderr || e2}`);
    });
    if (isPlaylist(info)) {
      if (info.entries.length === 0)
        throw new import_distube.DisTubeError("YTDLP_ERROR", "The playlist is empty");
      const playlist = {
        ...info,
        source: info.extractor,
        songs: info.entries.map((i) => new import_distube.Song(i, { member, source: i.extractor, metadata }))
      };
      return new import_distube.Playlist(playlist, { member, metadata });
    }
    return new import_distube.Song(info, { member, source: info.extractor, metadata });
  }
  async getStreamURL(url) {
    const info = await json(url, {
      dumpSingleJson: true,
      noWarnings: true,
      noCallHome: true,
      preferFreeFormats: true,
      skipDownload: true,
      simulate: true,
      format: "ba/ba*"
    }).catch((e2) => {
      throw new import_distube.DisTubeError("YTDLP_ERROR", `${e2.stderr || e2}`);
    });
    if (isPlaylist(info))
      throw new import_distube.DisTubeError("YTDLP_ERROR", "Cannot get stream URL of a entire playlist");
    return info.url;
  }
};
__name(YtDlpPlugin, "YtDlpPlugin");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  YtDlpPlugin,
  download,
  json,
  raw
});
//# sourceMappingURL=index.js.map